#include <chrono>
#include <cmath>
#include <iomanip>
#include <memory>
#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/imu.hpp>
#include <sstream>
#include <std_msgs/msg/bool.hpp>
#include <std_msgs/msg/float32.hpp>
#include <std_msgs/msg/string.hpp>
#include <string>
#include <tf2/LinearMath/Matrix3x3.h>
#include <tf2/LinearMath/Quaternion.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>

using namespace std::chrono_literals;

class IMUSteeringControlNode : public rclcpp::Node
{
  public:
    IMUSteeringControlNode() : Node("imu_steering_control_node")
    {
        // ÌååÎùºÎØ∏ÌÑ∞ ÏÑ†Ïñ∏ Î∞è Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
        this->declare_parameter("kp", 2.0);
        this->declare_parameter("ki", 0.1);
        this->declare_parameter("kd", 0.3);
        this->declare_parameter("max_steer", 1.0);
        this->declare_parameter("control_frequency", 50.0);
        this->declare_parameter("angle_tolerance", 0.05); // ÏïΩ 3ÎèÑ

        // PID Í≤åÏù∏ ÌååÎùºÎØ∏ÌÑ∞ Î°úÎìú
        kp_ = this->get_parameter("kp").as_double();
        ki_ = this->get_parameter("ki").as_double();
        kd_ = this->get_parameter("kd").as_double();
        max_steer_ = this->get_parameter("max_steer").as_double();
        control_frequency_ = this->get_parameter("control_frequency").as_double();
        angle_tolerance_ = this->get_parameter("angle_tolerance").as_double();

        // ÏÉÅÌÉú Î≥ÄÏàò Ï¥àÍ∏∞Ìôî
        control_enabled_ = false;
        target_angle_ = 0.0;
        current_yaw_ = 0.0;
        imu_received_ = false;
        last_imu_time_ = this->now();

        // PID Ï†úÏñ¥ Î≥ÄÏàò Ï¥àÍ∏∞Ìôî
        error_prev_ = 0.0;
        error_integral_ = 0.0;
        last_control_time_ = this->now();
        current_steer_ = 0.0;
        current_throttle_ = 0.0;

        // Publishers
        control_pub_ = this->create_publisher<std_msgs::msg::String>("/dss/SetControl", 1);

        // Subscribers
        imu_sub_ = this->create_subscription<sensor_msgs::msg::Imu>(
            "/dss/imu", 10, std::bind(&IMUSteeringControlNode::imu_callback, this, std::placeholders::_1));

        target_angle_sub_ = this->create_subscription<std_msgs::msg::Float32>(
            "/steering/target_angle", 10,
            std::bind(&IMUSteeringControlNode::target_angle_callback, this, std::placeholders::_1));

        enable_sub_ = this->create_subscription<std_msgs::msg::Bool>(
            "/steering/enable", 10, std::bind(&IMUSteeringControlNode::enable_callback, this, std::placeholders::_1));

        throttle_sub_ = this->create_subscription<std_msgs::msg::Float32>(
            "/car/throttle", 10, std::bind(&IMUSteeringControlNode::throttle_callback, this, std::placeholders::_1));

        // Ï†úÏñ¥ ÌÉÄÏù¥Î®∏ (50Hz)
        double timer_period = 1.0 / control_frequency_;
        control_timer_ = this->create_wall_timer(std::chrono::duration<double>(timer_period),
                                                 std::bind(&IMUSteeringControlNode::control_timer_callback, this));

        // ÏÉÅÌÉú Ï∂úÎ†• ÌÉÄÏù¥Î®∏ (1Hz)
        status_timer_ = this->create_wall_timer(1s, std::bind(&IMUSteeringControlNode::status_timer_callback, this));

        RCLCPP_INFO(this->get_logger(), "üß≠ IMU Steering Control Node Started");
        RCLCPP_INFO(this->get_logger(), "PID Gains - Kp: %.3f, Ki: %.3f, Kd: %.3f", kp_, ki_, kd_);
        RCLCPP_INFO(this->get_logger(), "Max Steer: %.2f, Tolerance: %.3f rad", max_steer_, angle_tolerance_);
        RCLCPP_INFO(this->get_logger(), "‚è≥ Waiting for IMU data...");
    }

  private:
    // ROS2 Publishers/Subscribers
    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr control_pub_;
    rclcpp::Subscription<sensor_msgs::msg::Imu>::SharedPtr imu_sub_;
    rclcpp::Subscription<std_msgs::msg::Float32>::SharedPtr target_angle_sub_;
    rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr enable_sub_;
    rclcpp::Subscription<std_msgs::msg::Float32>::SharedPtr throttle_sub_;

    // Timers
    rclcpp::TimerBase::SharedPtr control_timer_;
    rclcpp::TimerBase::SharedPtr status_timer_;

    // Ï†úÏñ¥ ÏÉÅÌÉú
    bool control_enabled_;
    double target_angle_; // Î™©Ìëú Î∞©Ìñ•Í∞Å (rad)
    double current_yaw_;  // ÌòÑÏû¨ Î∞©Ìñ•Í∞Å (rad)
    bool imu_received_;
    rclcpp::Time last_imu_time_;
    double current_throttle_; // ÌòÑÏû¨ Ïä§Î°úÌãÄ Í∞í

    // PID Ï†úÏñ¥ Î≥ÄÏàò
    double kp_, ki_, kd_;
    double max_steer_;
    double control_frequency_;
    double angle_tolerance_;
    double error_prev_;
    double error_integral_;
    rclcpp::Time last_control_time_;
    double current_steer_;

    /**
     * IMU ÏΩúÎ∞± - QuaternionÏùÑ Yaw Í∞ÅÎèÑÎ°ú Î≥ÄÌôò
     */
    void imu_callback(const sensor_msgs::msg::Imu::SharedPtr msg)
    {
        try
        {
            // QuaternionÏùÑ tf2Î°ú Î≥ÄÌôò
            tf2::Quaternion q(msg->orientation.x, msg->orientation.y, msg->orientation.z, msg->orientation.w);

            // Roll, Pitch, Yaw Ï∂îÏ∂ú
            tf2::Matrix3x3 m(q);
            double roll, pitch, yaw;
            m.getRPY(roll, pitch, yaw);

            current_yaw_ = yaw;
            imu_received_ = true;
            last_imu_time_ = this->now();

            // Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú IMU Îç∞Ïù¥ÌÑ∞ Î°úÍ∑∏ Ï∂úÎ†• (2Hz)
            static int imu_log_counter = 0;
            if (++imu_log_counter % 25 == 0) // 50Hz -> 2Hz
            {
                RCLCPP_INFO(this->get_logger(), "üìä IMU Data - Yaw: %.3f rad (%.1f¬∞)", current_yaw_,
                            current_yaw_ * 180.0 / M_PI);
            }
        }
        catch (const std::exception &e)
        {
            RCLCPP_ERROR(this->get_logger(), "‚ùå IMU processing error: %s", e.what());
        }
    }

    /**
     * Î™©Ìëú Í∞ÅÎèÑ ÏÑ§Ï†ï ÏΩúÎ∞±
     */
    void target_angle_callback(const std_msgs::msg::Float32::SharedPtr msg)
    {
        double new_target = static_cast<double>(msg->data);

        // Í∞ÅÎèÑ Ï†ïÍ∑úÌôî (-œÄ ~ œÄ)
        new_target = normalize_angle(new_target);

        // Î™©Ìëú Í∞ÅÎèÑÍ∞Ä Ïã§Ï†úÎ°ú Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞Îßå Î°úÍ∑∏ Ï∂úÎ†•
        if (std::abs(new_target - target_angle_) > 0.01)
        {
            RCLCPP_INFO(this->get_logger(), "üéØ Target angle changed: %.3f -> %.3f rad (%.1f¬∞ -> %.1f¬∞)", target_angle_,
                        new_target, target_angle_ * 180.0 / M_PI, new_target * 180.0 / M_PI);

            // PID ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî (Î™©Ìëú Í∞ÅÎèÑ Î≥ÄÍ≤Ω Ïãú)
            error_prev_ = 0.0;
            error_integral_ = 0.0;
            last_control_time_ = this->now();
        }

        target_angle_ = new_target;
    }

    /**
     * Ï†úÏñ¥ ÌôúÏÑ±Ìôî/ÎπÑÌôúÏÑ±Ìôî ÏΩúÎ∞±
     */
    void enable_callback(const std_msgs::msg::Bool::SharedPtr msg)
    {
        bool prev_state = control_enabled_;
        control_enabled_ = msg->data;

        if (control_enabled_ && !prev_state)
        {
            RCLCPP_INFO(this->get_logger(), "‚úÖ IMU Steering Control ENABLED - Target: %.3f rad (%.1f¬∞)", target_angle_,
                        target_angle_ * 180.0 / M_PI);
            // PID ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            error_prev_ = 0.0;
            error_integral_ = 0.0;
            last_control_time_ = this->now();
            current_steer_ = 0.0;
        }
        else if (!control_enabled_ && prev_state)
        {
            RCLCPP_INFO(this->get_logger(), "‚ùå IMU Steering Control DISABLED");
            // ÏïàÏ†ÑÏùÑ ÏúÑÌï¥ Ï°∞Ìñ• Î∞è Ïä§Î°úÌãÄ Ï¥àÍ∏∞Ìôî
            current_steer_ = 0.0;
            current_throttle_ = 0.0;
            send_control_command(0.0, 0.0);
        }
    }

    /**
     * ÏÉÅÌÉú Ï∂úÎ†• ÌÉÄÏù¥Î®∏ ÏΩúÎ∞± (1Hz)
     */
    void status_timer_callback()
    {
        // IMU Îç∞Ïù¥ÌÑ∞ ÏàòÏã† ÏÉÅÌÉú ÌôïÏù∏
        auto time_since_last_imu = (this->now() - last_imu_time_).seconds();

        if (!imu_received_)
        {
            RCLCPP_WARN(this->get_logger(), "‚ö†Ô∏è  No IMU data received yet");
        }
        else if (time_since_last_imu > 2.0)
        {
            RCLCPP_WARN(this->get_logger(), "‚ö†Ô∏è  No IMU data for %.1f seconds", time_since_last_imu);
        }

        // Ï†úÏñ¥ ÏÉÅÌÉú Ï∂úÎ†•
        if (control_enabled_)
        {
            double error = angle_difference(target_angle_, current_yaw_);
            RCLCPP_INFO(this->get_logger(),
                        "üß≠ STEERING ACTIVE - Target: %.3f rad (%.1f¬∞) | Current: %.3f rad (%.1f¬∞) | Error: %.3f rad "
                        "(%.1f¬∞) | Steer: %.3f",
                        target_angle_, target_angle_ * 180.0 / M_PI, current_yaw_, current_yaw_ * 180.0 / M_PI, error,
                        error * 180.0 / M_PI, current_steer_);
        }
        else
        {
            RCLCPP_INFO(this->get_logger(),
                        "üß≠ STEERING INACTIVE - Current Yaw: %.3f rad (%.1f¬∞) | Target: %.3f rad (%.1f¬∞)", current_yaw_,
                        current_yaw_ * 180.0 / M_PI, target_angle_, target_angle_ * 180.0 / M_PI);
        }
    }

    /**
     * Ï†úÏñ¥ ÌÉÄÏù¥Î®∏ ÏΩúÎ∞± (50Hz)
     */
    void control_timer_callback()
    {
        if (!control_enabled_)
        {
            current_steer_ = 0.0;
            return;
        }

        // IMU Îç∞Ïù¥ÌÑ∞ ÏàòÏã† ÌôïÏù∏
        if (!imu_received_)
        {
            RCLCPP_WARN_THROTTLE(this->get_logger(), *this->get_clock(), 5000,
                                 "‚ö†Ô∏è  Cannot control - no IMU data received");
            return;
        }

        // PID Ï†úÏñ¥ Í≥ÑÏÇ∞
        compute_pid_control();

        // Ï∞®Îüâ Ï†úÏñ¥ Î™ÖÎ†π Ï†ÑÏÜ° (Ï°∞Ìñ• + Ïä§Î°úÌãÄ)
        send_control_command(current_steer_, current_throttle_);
    }

    /**
     * PID Ï†úÏñ¥ Í≥ÑÏÇ∞
     */
    void compute_pid_control()
    {
        rclcpp::Time current_time = this->now();
        double dt = (current_time - last_control_time_).seconds();

        // dtÍ∞Ä ÎÑàÎ¨¥ ÏûëÍ±∞ÎÇò ÌÅ∞ Í≤ΩÏö∞ Î≥¥Ìò∏
        if (dt <= 0.001 || dt > 1.0)
        {
            dt = 1.0 / control_frequency_;
        }

        // Í∞ÅÎèÑ Ïò§Ï∞® Í≥ÑÏÇ∞ (ÏµúÎã® Í≤ΩÎ°ú)
        double error = angle_difference(target_angle_, current_yaw_);

        // ÌóàÏö© Ïò§Ï∞® ÎÇ¥Ïóê ÏûàÏúºÎ©¥ Ï†úÏñ¥ Ï§ëÎã®
        if (std::abs(error) < angle_tolerance_)
        {
            current_steer_ = 0.0;
            error_integral_ = 0.0; // Ï†ÅÎ∂Ñ Î¶¨ÏÖã
            error_prev_ = error;
            last_control_time_ = current_time;
            return;
        }

        // Ï†ÅÎ∂Ñ Í≥ÑÏÇ∞ (windup Î∞©ÏßÄ)
        error_integral_ += error * dt;
        if (error_integral_ > 1.0)
            error_integral_ = 1.0;
        if (error_integral_ < -1.0)
            error_integral_ = -1.0;

        // ÎØ∏Î∂Ñ Í≥ÑÏÇ∞
        double error_derivative = (error - error_prev_) / dt;

        // PID Ï∂úÎ†• Í≥ÑÏÇ∞
        double pid_output = kp_ * error + ki_ * error_integral_ + kd_ * error_derivative;

        // Ï°∞Ìñ•Í∞í Ï†úÌïú (-1.0 ~ 1.0)
        current_steer_ = std::max(-max_steer_, std::min(max_steer_, pid_output));

        // Îã§Ïùå Í≥ÑÏÇ∞ÏùÑ ÏúÑÌïú Í∞í Ï†ÄÏû•
        error_prev_ = error;
        last_control_time_ = current_time;

        // ÏûêÏÑ∏Ìïú Ï†úÏñ¥ Î°úÍ∑∏ (5Hz)
        static int control_log_counter = 0;
        if (++control_log_counter % (static_cast<int>(control_frequency_) / 5) == 0)
        {
            RCLCPP_INFO(this->get_logger(),
                        "üéõÔ∏è  PID Control - Error: %.4f rad (%.2f¬∞), P: %.4f, I: %.4f, D: %.4f, Output: %.4f", error,
                        error * 180.0 / M_PI, kp_ * error, ki_ * error_integral_, kd_ * error_derivative, pid_output);
        }
    }

    /**
     * Ïä§Î°úÌãÄ Í∞í ÏàòÏã† ÏΩúÎ∞±
     */
    void throttle_callback(const std_msgs::msg::Float32::SharedPtr msg)
    {
        current_throttle_ = static_cast<double>(msg->data);

        // Ïä§Î°úÌãÄ Í∞í Î°úÍ∑∏ (2Ï¥àÎßàÎã§)
        static int throttle_log_counter = 0;
        if (++throttle_log_counter % (static_cast<int>(control_frequency_) * 2) == 0)
        {
            RCLCPP_INFO(this->get_logger(), "‚ö° Throttle updated: %.3f", current_throttle_);
        }
    }

    /**
     * Ï∞®Îüâ Ï†úÏñ¥ Î™ÖÎ†π Ï†ÑÏÜ° (Ï°∞Ìñ• + Ïä§Î°úÌãÄ)
     */
    void send_control_command(double steer, double throttle)
    {
        try
        {
            // Í∞ÑÎã®Ìïú Î¨∏ÏûêÏó¥ Ï°∞ÏûëÏúºÎ°ú JSON ÏÉùÏÑ±
            std::ostringstream json_stream;
            json_stream << std::fixed << std::setprecision(4);
            json_stream << "{"
                        << "\"steer\":" << steer << ","
                        << "\"throttle\":" << throttle << ","
                        << "\"brake\":0.0,"
                        << "\"parkBrake\":false,"
                        << "\"targetGear\":1,"
                        << "\"headLight\":false,"
                        << "\"tailLight\":false,"
                        << "\"turnSignal\":0,"
                        << "\"horn\":false,"
                        << "\"lightMode\":0,"
                        << "\"wiperMode\":0"
                        << "}";

            auto control_msg = std_msgs::msg::String();
            control_msg.data = json_stream.str();
            control_pub_->publish(control_msg);

            // Ï†úÏñ¥ Î™ÖÎ†π Î°úÍ∑∏ (5Hz)
            static int cmd_log_counter = 0;
            if (control_enabled_ && ++cmd_log_counter % (static_cast<int>(control_frequency_) / 5) == 0)
            {
                RCLCPP_INFO(this->get_logger(), "üöÄ Control Command: steer=%.4f, throttle=%.3f", steer, throttle);
            }
        }
        catch (const std::exception &e)
        {
            RCLCPP_ERROR(this->get_logger(), "‚ùå Failed to send control command: %s", e.what());
        }
    }

    /**
     * Í∞ÅÎèÑ Ï†ïÍ∑úÌôî (-œÄ ~ œÄ)
     */
    double normalize_angle(double angle)
    {
        while (angle > M_PI)
            angle -= 2.0 * M_PI;
        while (angle < -M_PI)
            angle += 2.0 * M_PI;
        return angle;
    }

    /**
     * Îëê Í∞ÅÎèÑ Í∞ÑÏùò ÏµúÎã® Í±∞Î¶¨ Ï∞®Ïù¥ Í≥ÑÏÇ∞
     */
    double angle_difference(double target, double current)
    {
        double diff = target - current;
        return normalize_angle(diff);
    }
};

int main(int argc, char *argv[])
{
    rclcpp::init(argc, argv);

    try
    {
        auto node = std::make_shared<IMUSteeringControlNode>();
        RCLCPP_INFO(node->get_logger(), "üöÄ Starting IMU steering control node...");
        rclcpp::spin(node);
    }
    catch (const std::exception &e)
    {
        std::cerr << "‚ùå Exception in IMU steering control node: " << e.what() << std::endl;
        return 1;
    }

    rclcpp::shutdown();
    return 0;
}
